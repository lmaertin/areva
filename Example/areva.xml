<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project>
<metrics>
<metric code="public Double calcRating() {&#13;&#10;     //KE pro LE = 1    &#13;&#10;    final double COSTS_PER_WIREUNIT = 1.00;&#13;&#10;&#13;&#10; &#9;//LE innerhalb eines Bereiches&#13;&#10;    final int IN_SAME_AREA = 1; &#13;&#10;    //LE Heck &lt;-&gt; Tür&#13;&#10;&#9;final int REAR_TO_DOOR = 3; &#13;&#10;    //LE Tür &lt;-&gt; Tür&#13;&#10;    final int DOOR_TO_DOOR = 3; &#13;&#10;    //LE Front &lt;-&gt; Tür&#13;&#10;    final int FRONT_TO_DOOR = 2; &#13;&#10;     //LE Heck &lt;-&gt; Front&#13;&#10;    final int REAR_TO_FRONT = 5;&#13;&#10;    //Leitungen pro Sensor-Verbindung&#13;&#10;    final int WIRES_PER_SENSOR = 1; &#13;&#10;    //Leitungen pro Aktuator-Verbindung&#13;&#10;    final int WIRES_PER_ACTUATOR = 1;  &#13;&#10;&#13;&#10;    final String FRONT = &quot;front&quot;;&#13;&#10;    final String REAR = &quot;rear&quot;;&#13;&#10;    final String LEFT = &quot;left&quot;;&#13;&#10;    final String RIGHT = &quot;right&quot;;&#13;&#10;&#13;&#10;    String location;&#13;&#10;    int sensorsFront;&#13;&#10;    int actuatorsFront;&#13;&#10;    int sensorsRear;&#13;&#10;    int actuatorsRear;&#13;&#10;    int sensorsLeft;&#13;&#10;    int actuatorsLeft;&#13;&#10;    int sensorsRight;&#13;&#10;    int actuatorsRight;&#13;&#10;    double costsPerEcu;&#13;&#10;    double totalCosts = 0;&#13;&#10;    for(Element ecuInstance : getEcuElementList()){&#13;&#10;      location = getTagValueFormElement(&quot;location&quot;, ecuInstance);&#13;&#10;      if(location.length() &gt; 0){&#13;&#10;        //Auswertung nur durchführen, wenn nicht Restbus-Steuergerät&#13;&#10;        sensorsFront = &#13;&#10;          getTagValueIntegerFormElement(&quot;sensorsFront&quot;, ecuInstance);&#13;&#10;        actuatorsFront = &#13;&#10;          getTagValueIntegerFormElement(&quot;actuatorsFront&quot;, ecuInstance);&#13;&#10;        sensorsRear = &#13;&#10;          getTagValueIntegerFormElement(&quot;sensorsRear&quot;, ecuInstance);&#13;&#10;        actuatorsRear = &#13;&#10;          getTagValueIntegerFormElement(&quot;actuatorsRear&quot;, ecuInstance);&#13;&#10;        sensorsLeft = &#13;&#10;          getTagValueIntegerFormElement(&quot;sensorsLeft&quot;, ecuInstance);&#13;&#10;        actuatorsLeft = &#13;&#10;          getTagValueIntegerFormElement(&quot;actuatorsLeft&quot;, ecuInstance);&#13;&#10;        sensorsRight = &#13;&#10;          getTagValueIntegerFormElement(&quot;sensorsRight&quot;, ecuInstance);&#13;&#10;        actuatorsRight = &#13;&#10;          getTagValueIntegerFormElement(&quot;actuatorsRight&quot;, ecuInstance);&#13;&#10;        costsPerEcu = 0;&#13;&#10;        if(location.equals(FRONT)){&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsFront * IN_SAME_AREA;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsFront * IN_SAME_AREA;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsRear * REAR_TO_FRONT;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsRear * REAR_TO_FRONT;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsLeft * FRONT_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsLeft * FRONT_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsRight * FRONT_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsRight * FRONT_TO_DOOR;&#13;&#10;        }&#13;&#10;        else if(location.equals(REAR)){&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsFront * REAR_TO_FRONT;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsFront * REAR_TO_FRONT;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsRear * IN_SAME_AREA;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsRear * IN_SAME_AREA;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsLeft * REAR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsLeft * REAR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsRight * REAR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsRight * REAR_TO_DOOR;&#13;&#10;        }&#13;&#10;        else if(location.equals(LEFT)){&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsFront * FRONT_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsFront * FRONT_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsRear * REAR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsRear * REAR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsLeft * IN_SAME_AREA;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsLeft * IN_SAME_AREA;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsRight * DOOR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsRight * DOOR_TO_DOOR;&#13;&#10;        }&#13;&#10;        else if(location.equals(RIGHT)){&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsFront * FRONT_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsFront * FRONT_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsRear * REAR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsRear * REAR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsLeft * DOOR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsLeft * DOOR_TO_DOOR;&#13;&#10;          costsPerEcu += WIRES_PER_SENSOR * sensorsRight * IN_SAME_AREA;&#13;&#10;          costsPerEcu += WIRES_PER_ACTUATOR * actuatorsRight * IN_SAME_AREA;&#13;&#10;        }&#13;&#10;        totalCosts += costsPerEcu;&#13;&#10;      }&#13;&#10;    }   &#13;&#10;    /* Alle SG verbinden (Bus-System):&#13;&#10;     * Front zu linke Tür +&#13;&#10;     * linke Tür zu Heck +&#13;&#10;     * Heck zu rechte Tür&#13;&#10;     */&#13;&#10;    totalCosts += FRONT_TO_DOOR + 2*REAR_TO_DOOR;&#13;&#10;    return totalCosts;&#13;&#10;}" name="KabelKosten"/>
<metric code="public Double calcRating() {&#13;&#10;    double totalCosts = 0.00;&#13;&#10;&#9;for (Element ecuInstance : getEcuElementList()) {&#13;&#10;&#9;&#9;totalCosts += getTagValueDoubleFormElement(&quot;price&quot;, ecuInstance);        &#13;&#10; &#9;}                                                        &#13;&#10; &#9;return totalCosts;&#13;&#10;&#9;&#13;&#10;}" name="KostenSteuergeräte"/>
<metric code="public static Double calcRating() {&#13;&#10;        return 8.0 * 2.0;&#13;&#10;}" name="KostenSchalter"/>
<metric code="public Double calcRating() {&#10;        int NUMBER_OF_SWC_MAX = 10; //Maximal erlaubte Anzahl der aSWCs einer Ecu&#13;&#10;&#13;&#10;    List&lt;Element&gt; ecuList = getEcuElementList();&#13;&#10;    int numberOfEcus = ecuList.size() - 1; //Anzahl der ersten SG ohne RBS&#13;&#10;    int numberOfSwcTotal = 0; //Gesamtanzahl aller aSWC &#13;&#10;    int numberOfSwcEcu; //Anzahl der aSWCs einer Ecu&#13;&#10;    String ecuName;&#13;&#10;    List&lt;Element&gt; aSWCList;&#13;&#10;    boolean isKo = false;&#13;&#10;    for(Element ecuInstance : ecuList){&#13;&#10;    &#9;ecuName = getNameFromElement(ecuInstance);&#13;&#10;      &#9;aSWCList = getAtomicSWCForEcuName(ecuName);&#13;&#10;      &#9;numberOfSwcEcu = 0;&#13;&#10;      &#9;for(Element aswc : aSWCList){&#13;&#10;            if(getTagValueFormElement(&quot;@isComplex&quot;, aswc).equals(&quot;true&quot;)){&#13;&#10;          &#9;numberOfSwcEcu++;&#13;&#10;           &#9;}&#13;&#10;      &#9;}&#13;&#10;&#13;&#10;      if(numberOfSwcEcu &lt;= NUMBER_OF_SWC_MAX){&#13;&#10;        numberOfSwcTotal += numberOfSwcEcu;&#13;&#10;      }&#13;&#10;      else{&#13;&#10;        isKo = true;&#13;&#10;        break;&#13;&#10;      }&#13;&#10;    }   &#13;&#10;&#13;&#10;    if(isKo)&#13;&#10;      return 11.0;&#13;&#10;    else&#13;&#10;      return (double) numberOfSwcTotal/numberOfEcus;&#10;}" name="PerformanzProzessor"/>
<metric code="public Double calcRating() {&#10;        int volume = 0; //Kommunikationsvolumen (bit)&#13;&#10;  &#13;&#10;      //1. Schritt HashMap mit Komponenten und Steuergeräten füllen&#13;&#10;      String ecuName; //Name des Steuergeräts&#13;&#10;      Map&lt;String, String&gt; componentRefEcuMap = new HashMap&lt;String, String&gt;();&#13;&#10;      for(Element ecuInstance : getEcuElementList()){&#13;&#10;        ecuName = getNameFromElement(ecuInstance);&#13;&#10;        //Referenzen der Komponenten auf dem selektierten SG ermitteln:&#13;&#10;        for(Element compIRef : getComponentRefElementListForEcuName(ecuName)){&#13;&#10;          componentRefEcuMap.put(getComponentRefForComponentIRefElement(compIRef),&#13;&#10;              ecuName);&#13;&#10;        }&#13;&#10;      }   &#13;&#10;  &#13;&#10;      /*&#13;&#10;       * 2. Schritt: &#13;&#10;       * Assembly-Konnektoren für die auf unterschiedlichen Steuergeräten liegenden&#13;&#10;       * Software-Komponenten. Die Kontrolle der Steuergeräte wird über die zuvor&#13;&#10;       * erstellten Hash-Map realisiert.&#13;&#10;       */&#13;&#10;      String providingComponentRef;&#13;&#10;      String requestingComponentRef;&#13;&#10;      for(Element connector : getAssemblyConnectorElementList()){&#13;&#10;        providingComponentRef = getProvidingComponentRefFromAssemblyConnector(connector);&#13;&#10;        requestingComponentRef = getRequestingComponentRefFromAssemblyConnector(connector);&#13;&#10;        if(componentRefEcuMap.containsKey(providingComponentRef) &amp;&amp;&#13;&#10;            componentRefEcuMap.containsKey(requestingComponentRef)&#9;&#13;&#10;            &amp;&amp; (!componentRefEcuMap.get(providingComponentRef).equals(&#13;&#10;                componentRefEcuMap.get(requestingComponentRef)))){&#13;&#10;          volume += determineLinksizeForConnector(connector);&#13;&#10;        }&#13;&#10;      }&#13;&#10;      return (double) volume ;&#13;&#10;}&#10;" name="PerformanzKommunikation"/>
<metric code="public Double calcRating() {&#10;    int CAPACITY_MAX = 512; //Maximale Speicherkapazität einer Ecu&#13;&#10;&#13;&#10;    List&lt;Element&gt; ecuList = getEcuElementList();&#13;&#10;    int numberOfEcus = ecuList.size() - 1; //Anzahl der ersten SG ohne RBS&#13;&#10;    int volumeOfConnectorTotal = 0; //Speicherbedarf aller lokalen Konnektoren &#13;&#10;    int volumeOfConnectorEcu; //Speicherbedarf der lok. Konnektoren einer Ecu&#13;&#10;    String ecuName;&#13;&#10;    boolean isKo = false;&#13;&#10;&#13;&#10;    for(Element ecuInstance : ecuList){&#13;&#10;      ecuName = getNameFromElement(ecuInstance);&#13;&#10;      volumeOfConnectorEcu = 0;&#13;&#10;      for(Element composition : getCompositionsForEcuName(ecuName)){&#13;&#10;        //nur die Assembly-Konnektoren der Kompositionen betrachten:&#13;&#10;        for(Element connector : &#13;&#10;          getAssemblyConnectorsForCompositionTypeElement(composition)){&#13;&#10;          volumeOfConnectorEcu += determineLinksizeForConnector(connector);&#13;&#10;        }&#9;&#9;&#9;&#9;&#9;&#13;&#10;      }&#13;&#10;&#13;&#10;      if(volumeOfConnectorEcu &lt;=CAPACITY_MAX){&#13;&#10;        volumeOfConnectorTotal += volumeOfConnectorEcu;&#13;&#10;      }&#13;&#10;      else{&#13;&#10;        isKo = true;&#13;&#10;        break;&#13;&#10;      }&#13;&#10;    }   &#13;&#10;&#13;&#10;    if(isKo)&#13;&#10;      return 513.0;&#13;&#10;    else&#13;&#10;      return (double) volumeOfConnectorTotal/numberOfEcus;&#13;&#10;  }&#10;" name="PerformanzSpeicher"/>
<metric code="public Double calcRating() {&#10;        return 7.0;&#10;}" name="Erweiterbarkeit"/>
<metric code="public Double calcRating() {&#10;        return 12.0;&#10;}" name="Skalierbarkeit"/>
<metric code="public Double calcRating() {&#10;        return 7.24;&#10;}" name="VerfügbarkeitKommunikation"/>
<metric code="public Double calcRating() {&#10;        return 2.6;&#10;}" name="VerfügbarkeitSteuergeräte"/>
</metrics>
<qualityRatings>
<qualityRating name="KostenKabel">
<function interval="[0,20]" term="100.0"/>
<function interval="[35,40]" term="-0.044862973945 * x^3 + 4.72212983408 * x * x - 166.21367263895 * x + 2050.369503501356"/>
<function interval="" term=""/>
</qualityRating>
<qualityRating name="KostenSchalter">
<function interval="[0,30]" term="x*1"/>
<function interval="" term=""/>
<function interval="" term=""/>
</qualityRating>
<qualityRating name="KostenSteuergeräte">
<function interval="[0,8]" term="-12.5 * x + 100.0"/>
</qualityRating>
<qualityRating name="Modifizierbarkeit"/>
<qualityRating name="PerformanzProzessor">
<function interval="(2,6]" term="-0.394900459159 * x *x *x + 2.007229132429 * x * x - 3.773009183175 * x + 102.676305509905"/>
<function interval="(6,20]" term="80+(x-4)*0.2"/>
</qualityRating>
<qualityRating name="PerformanzSpeicher">
<function interval="[0,100]" term="100"/>
</qualityRating>
<qualityRating name="PerformanzKommunikation">
<function interval="(60,80]" term="-0.001036256906 * x^3 + 0.175587016575 * x * x - 10.595580110497 * x + 310.453038674033"/>
</qualityRating>
<qualityRating name="Erweiterbarkeit">
<function interval="[0,10]" term="-90.0 / 7.0 * x + 970.0 / 7.0"/>
</qualityRating>
<qualityRating name="Skalierbarkeit">
<function interval="[6,20]" term="-45.0 / 7.0 * x + 970.0 / 7.0"/>
</qualityRating>
<qualityRating name="VerfügbarkeitSteuergeräte">
<function interval="[0,8]" term="25.0 / 2.0 * x + 0.0"/>
</qualityRating>
<qualityRating name="Test">
<function interval="[0,5]" term="x"/>
<function interval="[10,12]" term="10"/>
<function interval="[14,20]" term="-x"/>
<function interval="[22,30]" term="x^(2-1)"/>
<function interval="[35,50]" term="x-6"/>
<function interval="[60,70]" term="-x+3"/>
</qualityRating>
</qualityRatings>
</project>
